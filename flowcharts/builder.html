<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Flowchart Builder - Fowlerville Wrestling</title>
  <link rel="stylesheet" href="../css/styles.css">
  <style>
    body { overflow: hidden; display: flex; flex-direction: column; height: 100vh; }
    .site-nav { flex-shrink: 0; }

    .builder-toolbar {
      background: var(--card-bg);
      border-bottom: 1px solid var(--border);
      padding: 0.5rem 1rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex-wrap: wrap;
      flex-shrink: 0;
    }
    .builder-toolbar .tb-group {
      display: flex;
      gap: 0.3rem;
      align-items: center;
    }
    .builder-toolbar .tb-sep {
      width: 1px;
      height: 24px;
      background: var(--border);
      margin: 0 0.4rem;
    }
    .tb-btn {
      padding: 0.35rem 0.7rem;
      border: 1px solid var(--border);
      border-radius: 4px;
      background: white;
      font-size: 0.8rem;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.15s, border-color 0.15s;
      white-space: nowrap;
    }
    .tb-btn:hover { background: #f0f0f0; }
    .tb-btn.active {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
    }
    .tb-btn.node-root-btn { border-left: 3px solid var(--primary); }
    .tb-btn.node-action-btn { border-left: 3px solid #999; }
    .tb-btn.node-finish-btn { border-left: 3px solid #6a8eae; }
    .tb-btn.node-link-btn { border-left: 3px solid #856404; }

    .builder-legend {
      background: var(--card-bg);
      border-bottom: 1px solid var(--border);
      padding: 0.4rem 1rem;
      display: flex;
      gap: 1.5rem;
      justify-content: center;
      flex-wrap: wrap;
      font-size: 0.8rem;
      flex-shrink: 0;
    }
    .legend-item { display: flex; align-items: center; gap: 0.4rem; }
    .legend-dot {
      width: 14px; height: 10px; border-radius: 50%;
      border: 2px solid var(--primary);
    }
    .legend-dot.root { background: var(--primary); }
    .legend-dot.action { background: #d9d9d9; }
    .legend-dot.finish { background: #e8eef4; }
    .legend-dot.link { background: #fff3cd; border-color: #856404; }

    .canvas-wrap {
      flex: 1;
      overflow: auto;
      background: #f9f9f6;
      position: relative;
      cursor: crosshair;
    }
    .canvas-wrap.mode-move { cursor: default; }
    .canvas-wrap.mode-connect { cursor: crosshair; }
    .canvas-wrap.mode-delete { cursor: not-allowed; }

    #canvas {
      display: block;
    }

    /* Reuse flowchart node styles from shared CSS */
    .fc-node { cursor: grab; }
    .fc-node.dragging { cursor: grabbing; }
    .fc-node.connect-source ellipse { stroke-width: 3; stroke: var(--accent); }
    .fc-node.delete-hover ellipse { stroke: #c00; stroke-width: 3; }
    .fc-edge.delete-hover path { stroke: #c00; stroke-width: 3; }

    .node-label-input {
      position: absolute;
      border: 2px solid var(--primary);
      border-radius: 4px;
      padding: 0.3rem 0.5rem;
      font-size: 13px;
      font-family: inherit;
      text-align: center;
      outline: none;
      z-index: 10;
      min-width: 120px;
    }

    .status-msg {
      position: fixed;
      bottom: 1rem;
      left: 50%;
      transform: translateX(-50%);
      background: var(--primary);
      color: white;
      padding: 0.5rem 1.2rem;
      border-radius: 4px;
      font-size: 0.85rem;
      z-index: 20;
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
    }
    .status-msg.show { opacity: 1; }

    .chart-title {
      display: none;
      background: var(--card-bg);
      border-bottom: 1px solid var(--border);
      padding: 0.4rem 1rem;
      text-align: center;
      font-size: 1rem;
      font-weight: 600;
      color: var(--primary);
      flex-shrink: 0;
    }

    .canvas-wrap.mode-preview { cursor: default; }
    .canvas-wrap.mode-preview .fc-node { cursor: pointer; }

    .preview-banner {
      display: none;
      background: var(--primary);
      color: white;
      text-align: center;
      padding: 0.3rem 1rem;
      font-size: 0.85rem;
      font-weight: 500;
      flex-shrink: 0;
    }
    .preview-banner.show { display: block; }

    @media print {
      .site-nav, .builder-toolbar, .builder-legend, .status-msg, .preview-banner { display: none !important; }
      .chart-title { display: block !important; font-size: 1.5rem; border: none; }
      body { overflow: visible; height: auto; }
      .canvas-wrap { overflow: visible; cursor: default; }
      #canvas { max-width: 100%; height: auto; }
    }

    @media (max-width: 768px) {
      .builder-toolbar { padding: 0.4rem 0.5rem; gap: 0.3rem; }
      .tb-btn { padding: 0.25rem 0.5rem; font-size: 0.75rem; }
      .tb-sep { margin: 0 0.2rem; }
    }
  </style>
</head>
<body>
  <script>window.NAV_BASE = '../';</script>
  <script src="../js/nav.js"></script>

  <div class="builder-toolbar" id="toolbar">
    <div class="tb-group">
      <button class="tb-btn node-root-btn" data-add="root" title="Add starting position node">Starting Position</button>
      <button class="tb-btn node-action-btn" data-add="action" title="Add technique/action node">Technique</button>
      <button class="tb-btn node-finish-btn" data-add="finish" title="Add finish node">Finish</button>
      <button class="tb-btn node-link-btn" data-add="link" title="Add link to another series">Link</button>
    </div>
    <div class="tb-sep"></div>
    <div class="tb-group">
      <button class="tb-btn" id="btn-connect" title="Connect two nodes">Connect</button>
      <button class="tb-btn" id="btn-delete" title="Delete a node or edge">Delete</button>
    </div>
    <div class="tb-sep"></div>
    <div class="tb-group">
      <button class="tb-btn" id="btn-clear" title="Clear canvas">Clear</button>
      <button class="tb-btn" id="btn-print" title="Print flowchart">Print</button>
      <button class="tb-btn" id="btn-export" title="Export as JSON">Export JSON</button>
      <button class="tb-btn" id="btn-import" title="Import from JSON file">Import JSON</button>
      <input type="file" id="import-file" accept=".json" style="display:none">
    </div>
    <div class="tb-sep"></div>
    <div class="tb-group">
      <button class="tb-btn" id="btn-preview" title="Preview with technique popups">Preview</button>
    </div>
  </div>

  <div class="builder-legend">
    <div class="legend-item"><div class="legend-dot root"></div> Starting Position</div>
    <div class="legend-item"><div class="legend-dot action"></div> Technique / Action</div>
    <div class="legend-item"><div class="legend-dot finish"></div> Finish</div>
    <div class="legend-item"><div class="legend-dot link"></div> Links to Another Series</div>
  </div>

  <div class="chart-title" id="chart-title"></div>

  <div class="canvas-wrap" id="canvas-wrap">
    <svg id="canvas" xmlns="http://www.w3.org/2000/svg" width="2000" height="1500">
      <defs></defs>
      <g id="edges-layer"></g>
      <g id="nodes-layer"></g>
    </svg>
  </div>

  <div class="preview-banner" id="preview-banner">Preview Mode — click any node to see technique details &amp; videos. Click "Preview" again to return to editing.</div>

  <!-- Popup for preview mode -->
  <div class="popup-overlay" id="popup" onclick="if(event.target===this)document.getElementById('popup').classList.remove('active')">
    <div class="popup-panel">
      <button class="popup-close" onclick="document.getElementById('popup').classList.remove('active')">&times;</button>
      <div id="popup-content"></div>
    </div>
  </div>

  <div class="status-msg" id="status"></div>

  <script>
  (function() {
    // --- Data Model ---
    let nodes = [];
    let edges = [];
    let nextId = 1;

    const NODE_RX = 75;
    const NODE_RY = 25;

    // --- Chart loading from URL param ---
    const urlParams = new URLSearchParams(window.location.search);
    const chartId = urlParams.get('chart');
    let chartMeta = null; // stores original flowchart metadata for export

    // --- Technique data for autocomplete and preview popups ---
    let techniquesData = null;
    let techniqueNames = [];
    fetch('../techniques.json')
      .then(r => r.json())
      .then(data => {
        techniquesData = data;
        for (const cat of data.categories) {
          for (const t of cat.techniques) {
            techniqueNames.push(t.name);
          }
        }
      })
      .catch(() => {});

    // --- Mode state ---
    let mode = 'add';       // 'add' | 'connect' | 'delete'
    let addType = null;     // node type to place on click
    let connectFrom = null; // source node id during connect

    // --- DOM refs ---
    const svg = document.getElementById('canvas');
    const nodesLayer = document.getElementById('nodes-layer');
    const edgesLayer = document.getElementById('edges-layer');
    const wrap = document.getElementById('canvas-wrap');
    const statusEl = document.getElementById('status');

    // --- SVG helpers ---
    function svgPoint(e) {
      const rect = svg.getBoundingClientRect();
      return {
        x: e.clientX - rect.left + wrap.scrollLeft,
        y: e.clientY - rect.top + wrap.scrollTop
      };
    }

    function showStatus(msg) {
      statusEl.textContent = msg;
      statusEl.classList.add('show');
      clearTimeout(statusEl._t);
      statusEl._t = setTimeout(() => statusEl.classList.remove('show'), 2000);
    }

    // --- Rendering ---
    function render() {
      // Clear
      nodesLayer.innerHTML = '';
      edgesLayer.innerHTML = '';

      // Draw edges
      edges.forEach((edge, idx) => {
        const from = nodes.find(n => n.id === edge.from);
        const to = nodes.find(n => n.id === edge.to);
        if (!from || !to) return;

        const dx = to.x - from.x;
        const dy = to.y - from.y;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;

        // Adjust for ellipse borders
        const fromRy = NODE_RY;
        const toRy = NODE_RY;
        const angle = Math.atan2(dy, dx);

        const x1 = from.x + NODE_RX * Math.cos(angle) * 0.8;
        const y1 = from.y + fromRy * Math.sin(angle) * 1.2;
        const x2 = to.x - NODE_RX * Math.cos(angle) * 0.8;
        const y2 = to.y - toRy * Math.sin(angle) * 1.2;

        const midX = (x1 + x2) / 2;
        const midY = (y1 + y2) / 2;

        // Perpendicular offset for curve
        const perpX = -(y2 - y1) * 0.1;
        const perpY = (x2 - x1) * 0.1;

        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.classList.add('fc-edge');
        g.dataset.idx = idx;

        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', `M ${x1} ${y1} Q ${midX + perpX} ${midY + perpY}, ${x2} ${y2}`);
        path.style.strokeWidth = '3.5';
        path.style.stroke = '#888';
        path.style.strokeDasharray = '10 5';
        path.style.strokeLinecap = 'round';
        path.style.fill = 'none';

        // Wider invisible hit area for clicking
        const hitPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        hitPath.setAttribute('d', `M ${x1} ${y1} Q ${midX + perpX} ${midY + perpY}, ${x2} ${y2}`);
        hitPath.style.stroke = 'transparent';
        hitPath.style.strokeWidth = '12';
        hitPath.style.fill = 'none';
        hitPath.style.cursor = mode === 'delete' ? 'not-allowed' : 'default';

        g.appendChild(hitPath);
        g.appendChild(path);

        if (mode === 'delete') {
          g.addEventListener('mouseenter', () => g.classList.add('delete-hover'));
          g.addEventListener('mouseleave', () => g.classList.remove('delete-hover'));
          g.addEventListener('click', (e) => {
            e.stopPropagation();
            edges.splice(idx, 1);
            render();
            showStatus('Edge deleted');
          });
        }

        edgesLayer.appendChild(g);
      });

      // Draw nodes
      nodes.forEach(node => {
        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.classList.add('fc-node', 'node-' + node.type);
        g.dataset.id = node.id;

        const ellipse = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
        ellipse.setAttribute('cx', node.x);
        ellipse.setAttribute('cy', node.y);
        ellipse.setAttribute('rx', NODE_RX);
        ellipse.setAttribute('ry', NODE_RY);
        g.appendChild(ellipse);

        // Multi-line text
        const lines = wrapText(node.label, 18);
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', node.x);
        text.setAttribute('y', node.y - (lines.length - 1) * 8);

        lines.forEach((line, i) => {
          const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
          tspan.setAttribute('x', node.x);
          if (i > 0) tspan.setAttribute('dy', '16');
          tspan.textContent = line;
          text.appendChild(tspan);
        });
        g.appendChild(text);

        // Interactions
        setupNodeInteractions(g, node);
        nodesLayer.appendChild(g);
      });

      // Expand SVG if nodes are near edges
      expandCanvas();
    }

    function wrapText(label, maxLen) {
      if (label.length <= maxLen) return [label];
      const words = label.split(' ');
      const lines = [];
      let line = '';
      words.forEach(w => {
        if ((line + ' ' + w).trim().length > maxLen && line) {
          lines.push(line);
          line = w;
        } else {
          line = (line + ' ' + w).trim();
        }
      });
      if (line) lines.push(line);
      return lines;
    }

    function expandCanvas() {
      let maxX = 2000, maxY = 1500;
      nodes.forEach(n => {
        if (n.x + NODE_RX + 100 > maxX) maxX = n.x + NODE_RX + 100;
        if (n.y + NODE_RY + 100 > maxY) maxY = n.y + NODE_RY + 100;
      });
      svg.setAttribute('width', maxX);
      svg.setAttribute('height', maxY);
    }

    // --- Node Interactions ---
    function setupNodeInteractions(g, node) {
      let dragState = null;

      g.addEventListener('mousedown', (e) => {
        if (mode === 'preview' || mode === 'connect' || mode === 'delete') return;
        e.preventDefault();
        const pt = svgPoint(e);
        dragState = { startX: pt.x, startY: pt.y, nodeX: node.x, nodeY: node.y, moved: false };

        function onMove(me) {
          const mp = svgPoint(me);
          const dx = mp.x - dragState.startX;
          const dy = mp.y - dragState.startY;
          if (Math.abs(dx) > 3 || Math.abs(dy) > 3) dragState.moved = true;
          if (dragState.moved) {
            node.x = Math.max(NODE_RX, dragState.nodeX + dx);
            node.y = Math.max(NODE_RY, dragState.nodeY + dy);
            render();
          }
        }

        function onUp() {
          document.removeEventListener('mousemove', onMove);
          document.removeEventListener('mouseup', onUp);
          dragState = null;
        }

        document.addEventListener('mousemove', onMove);
        document.addEventListener('mouseup', onUp);
      });

      g.addEventListener('click', (e) => {
        e.stopPropagation();

        if (mode === 'preview') {
          showNodePopup(node);
          return;
        }

        if (mode === 'connect') {
          if (!connectFrom) {
            connectFrom = node.id;
            g.classList.add('connect-source');
            showStatus('Now click the target node');
          } else if (connectFrom !== node.id) {
            // Check for duplicate edge
            const exists = edges.some(ed => ed.from === connectFrom && ed.to === node.id);
            if (!exists) {
              edges.push({ from: connectFrom, to: node.id });
              showStatus('Edge created');
            } else {
              showStatus('Edge already exists');
            }
            connectFrom = null;
            render();
          }
          return;
        }

        if (mode === 'delete') {
          // Remove node and its edges
          edges = edges.filter(ed => ed.from !== node.id && ed.to !== node.id);
          nodes = nodes.filter(n => n.id !== node.id);
          render();
          showStatus('Node deleted');
          return;
        }
      });

      // Double-click to edit label (not in preview mode)
      g.addEventListener('dblclick', (e) => {
        if (mode === 'preview') return;
        e.preventDefault();
        e.stopPropagation();
        editNodeLabel(node);
      });

      if (mode === 'delete') {
        g.addEventListener('mouseenter', () => g.classList.add('delete-hover'));
        g.addEventListener('mouseleave', () => g.classList.remove('delete-hover'));
      }
    }

    function editNodeLabel(node) {
      const rect = svg.getBoundingClientRect();
      const scrollL = wrap.scrollLeft;
      const scrollT = wrap.scrollTop;

      // Build datalist from technique names
      const listId = 'tech-suggestions';
      let datalist = document.getElementById(listId);
      if (!datalist) {
        datalist = document.createElement('datalist');
        datalist.id = listId;
        document.body.appendChild(datalist);
      }
      datalist.innerHTML = techniqueNames.map(n => `<option value="${n}">`).join('');

      const input = document.createElement('input');
      input.type = 'text';
      input.className = 'node-label-input';
      input.setAttribute('list', listId);
      input.value = node.label;
      input.style.left = (node.x - 60 + rect.left - wrap.getBoundingClientRect().left + scrollL) + 'px';
      input.style.top = (node.y - 12 + rect.top - wrap.getBoundingClientRect().top + scrollT) + 'px';

      wrap.appendChild(input);
      input.focus();
      input.select();

      function finish() {
        const val = input.value.trim();
        if (val) node.label = val;
        input.remove();
        render();
      }

      input.addEventListener('blur', finish);
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') { e.preventDefault(); input.blur(); }
        if (e.key === 'Escape') { input.value = node.label; input.blur(); }
      });
    }

    // --- Canvas click (add node) ---
    wrap.addEventListener('click', (e) => {
      if (e.target.closest('.fc-node') || e.target.closest('.fc-edge')) return;
      if (mode !== 'add' || !addType) return;

      const pt = svgPoint(e);
      nodes.push({
        id: 'n' + nextId++,
        label: addType === 'root' ? 'Starting Position' :
               addType === 'finish' ? 'Finish' :
               addType === 'link' ? 'Link' : 'Technique',
        type: addType,
        x: pt.x,
        y: pt.y
      });
      render();
      showStatus('Node added - double-click to rename');
    });

    // --- Toolbar buttons ---
    const toolbar = document.getElementById('toolbar');

    // Node type add buttons
    toolbar.querySelectorAll('[data-add]').forEach(btn => {
      btn.addEventListener('click', () => {
        setMode('add');
        addType = btn.dataset.add;
        clearActiveButtons();
        btn.classList.add('active');
        showStatus('Click on canvas to place node');
      });
    });

    document.getElementById('btn-connect').addEventListener('click', () => {
      if (mode === 'connect') { setMode('add'); return; }
      setMode('connect');
      document.getElementById('btn-connect').classList.add('active');
      showStatus('Click source node, then target node');
    });

    document.getElementById('btn-delete').addEventListener('click', () => {
      if (mode === 'delete') { setMode('add'); return; }
      setMode('delete');
      document.getElementById('btn-delete').classList.add('active');
      showStatus('Click a node or edge to delete it');
    });

    document.getElementById('btn-clear').addEventListener('click', () => {
      if (nodes.length === 0 && edges.length === 0) return;
      if (!confirm('Clear the entire flowchart?')) return;
      nodes = [];
      edges = [];
      nextId = 1;
      render();
      showStatus('Canvas cleared');
    });

    document.getElementById('btn-print').addEventListener('click', () => {
      // Fit SVG to content before printing
      if (nodes.length > 0) {
        let minX = Infinity, minY = Infinity, maxX = 0, maxY = 0;
        nodes.forEach(n => {
          minX = Math.min(minX, n.x - NODE_RX - 20);
          minY = Math.min(minY, n.y - NODE_RY - 20);
          maxX = Math.max(maxX, n.x + NODE_RX + 20);
          maxY = Math.max(maxY, n.y + NODE_RY + 20);
        });
        svg.setAttribute('viewBox', `${minX} ${minY} ${maxX - minX} ${maxY - minY}`);
        svg.setAttribute('width', maxX - minX);
        svg.setAttribute('height', maxY - minY);
      }
      window.print();
      // Restore after print
      expandCanvas();
      svg.removeAttribute('viewBox');
    });

    function setMode(m) {
      mode = m;
      connectFrom = null;
      addType = null;
      clearActiveButtons();
      wrap.className = 'canvas-wrap' +
        (m === 'connect' ? ' mode-connect' :
         m === 'delete' ? ' mode-delete' :
         m === 'preview' ? ' mode-preview' :
         m === 'add' ? '' : ' mode-move');
      document.getElementById('preview-banner').classList.toggle('show', m === 'preview');
      if (m === 'preview') document.getElementById('btn-preview').classList.add('active');
      render();
    }

    function clearActiveButtons() {
      toolbar.querySelectorAll('.tb-btn').forEach(b => b.classList.remove('active'));
    }

    // Escape to exit modes / close popup
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        const popup = document.getElementById('popup');
        if (popup.classList.contains('active')) {
          popup.classList.remove('active');
        } else {
          setMode('add');
        }
      }
    });

    // Touch support for mobile
    let touchNode = null;
    let touchStart = null;

    svg.addEventListener('touchstart', (e) => {
      const touch = e.touches[0];
      const target = document.elementFromPoint(touch.clientX, touch.clientY);
      const nodeG = target && target.closest('.fc-node');
      if (!nodeG) return;

      const nodeId = nodeG.dataset.id;
      const node = nodes.find(n => n.id === nodeId);
      if (!node) return;

      if (mode === 'preview' || mode === 'connect' || mode === 'delete') return;

      e.preventDefault();
      const pt = svgPoint(touch);
      touchNode = node;
      touchStart = { x: pt.x, y: pt.y, nodeX: node.x, nodeY: node.y };
    }, { passive: false });

    svg.addEventListener('touchmove', (e) => {
      if (!touchNode || !touchStart) return;
      e.preventDefault();
      const pt = svgPoint(e.touches[0]);
      touchNode.x = Math.max(NODE_RX, touchStart.nodeX + (pt.x - touchStart.x));
      touchNode.y = Math.max(NODE_RY, touchStart.nodeY + (pt.y - touchStart.y));
      render();
    }, { passive: false });

    svg.addEventListener('touchend', () => {
      touchNode = null;
      touchStart = null;
    });

    // --- Preview mode ---
    document.getElementById('btn-preview').addEventListener('click', () => {
      if (mode === 'preview') { setMode('add'); return; }
      setMode('preview');
      showStatus('Click any node to see technique details');
    });

    function findTechnique(label) {
      if (!techniquesData) return null;
      const labelLower = label.toLowerCase();
      for (const cat of techniquesData.categories) {
        for (const t of cat.techniques) {
          if (t.name.toLowerCase() === labelLower ||
              labelLower.includes(t.name.toLowerCase()) ||
              t.name.toLowerCase().includes(labelLower)) {
            return t;
          }
        }
      }
      return null;
    }

    function showNodePopup(node) {
      const technique = findTechnique(node.label);
      const content = document.getElementById('popup-content');

      let html = '<h2 style="color:var(--primary);margin-bottom:0.5rem;">' + node.label + '</h2>';

      if (technique) {
        html += '<p style="margin-bottom:1rem;">' + technique.description + '</p>';
        if (technique.keyPoints && technique.keyPoints.length) {
          html += '<h3 style="color:var(--primary-light);margin-bottom:0.5rem;">Key Points</h3>';
          html += '<ul class="key-points">' + technique.keyPoints.map(p => '<li>' + p + '</li>').join('') + '</ul>';
        }
        if (technique.videos && technique.videos.length) {
          html += '<h3 style="color:var(--primary-light);margin:1rem 0 0.5rem;">Video</h3>';
          const v = technique.videos[0];
          html += '<div class="video-container"><iframe src="https://www.youtube.com/embed/' + v.id + '" allowfullscreen loading="lazy"></iframe></div>';
          html += '<p style="font-size:0.85rem;color:var(--text-light);">' + v.title + '</p>';
        }
        html += '<div style="margin-top:1rem;"><a href="../techniques.html#' + technique.id + '" class="btn btn-primary" style="color:white;" target="_blank">View Full Details</a></div>';
      } else {
        html += '<p style="color:var(--text-light);">No matching technique found in the database.</p>';
        const searchTerm = node.label.toLowerCase().replace(/[^a-z0-9]+/g, '-');
        html += '<div style="margin-top:1rem;"><a href="../techniques.html#' + searchTerm + '" class="btn btn-outline" target="_blank">Search Techniques</a></div>';
      }

      content.innerHTML = html;
      document.getElementById('popup').classList.add('active');
    }

    // --- Export JSON ---
    document.getElementById('btn-export').addEventListener('click', () => {
      if (nodes.length === 0) { showStatus('Nothing to export'); return; }

      const nodesOut = nodes.map(n => ({ id: n.id, label: n.label, type: n.type }));
      const edgesOut = edges.map(e => ({ from: e.from, to: e.to }));

      let exportData;
      if (chartMeta) {
        // Full techniques.json-ready flowchart object
        const rootNode = chartMeta.rootNode || (nodes.find(n => n.type === 'root') || nodes[0]).id;
        exportData = {
          id: chartMeta.id,
          name: chartMeta.name,
          slide: chartMeta.slide,
          file: chartMeta.file,
          rootNode: rootNode,
          nodes: nodesOut,
          edges: edgesOut
        };
      } else {
        // Blank canvas — include rootNode if one exists
        const rootN = nodes.find(n => n.type === 'root');
        exportData = { nodes: nodesOut, edges: edgesOut };
        if (rootN) exportData.rootNode = rootN.id;
      }

      const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = (chartMeta ? chartMeta.id : 'flowchart') + '.json';
      a.click();
      URL.revokeObjectURL(url);
      showStatus('JSON exported');
    });

    // --- Import JSON ---
    document.getElementById('btn-import').addEventListener('click', () => {
      document.getElementById('import-file').click();
    });

    document.getElementById('import-file').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        try {
          const data = JSON.parse(ev.target.result);
          if (!data.nodes || !Array.isArray(data.nodes)) {
            showStatus('Invalid JSON: missing nodes array');
            return;
          }

          // Check if nodes already have positions
          const hasPositions = data.nodes.some(n => typeof n.x === 'number');

          if (hasPositions) {
            nodes = data.nodes.map(n => ({
              id: n.id,
              label: n.label,
              type: n.type || 'action',
              x: n.x,
              y: n.y
            }));
          } else {
            // Auto-layout using BFS tree layout
            const rootNode = data.rootNode || (data.nodes.find(n => n.type === 'root') || data.nodes[0]).id;
            const positions = layoutTree({ nodes: data.nodes, edges: data.edges || [], rootNode });
            nodes = data.nodes.map(n => ({
              id: n.id,
              label: n.label,
              type: (n.type === 'reaction') ? 'action' : (n.type || 'action'),
              x: positions[n.id] ? positions[n.id].x : 200,
              y: positions[n.id] ? positions[n.id].y : 200
            }));
          }

          edges = (data.edges || []).map(e => ({ from: e.from, to: e.to }));
          nextId = nodes.length + 1;
          render();
          showStatus('Imported: ' + file.name);
        } catch(err) {
          showStatus('Error reading JSON file');
          console.error(err);
        }
      };
      reader.readAsText(file);
      e.target.value = '';
    });

    // --- Load existing flowchart from techniques.json ---
    function layoutTree(fc) {
      const rootId = fc.rootNode;
      const children = {};

      for (const e of fc.edges) {
        if (!children[e.from]) children[e.from] = [];
        children[e.from].push(e.to);
      }

      // BFS to get levels
      const levels = {};
      const queue = [rootId];
      levels[rootId] = 0;
      const visited = new Set([rootId]);

      while (queue.length) {
        const nid = queue.shift();
        for (const child of (children[nid] || [])) {
          if (!visited.has(child)) {
            levels[child] = levels[nid] + 1;
            visited.add(child);
            queue.push(child);
          }
        }
      }

      // Add orphan nodes
      for (const n of fc.nodes) {
        if (!(n.id in levels)) levels[n.id] = 1;
      }

      // Group by level
      const levelGroups = {};
      for (const [nid, lvl] of Object.entries(levels)) {
        if (!levelGroups[lvl]) levelGroups[lvl] = [];
        levelGroups[lvl].push(nid);
      }

      const maxLevel = Math.max(...Object.values(levels));
      const NODE_W = 150, NODE_H = 50, H_GAP = 30, V_GAP = 100;

      let maxWidth = 0;
      for (let lvl = 0; lvl <= maxLevel; lvl++) {
        const group = levelGroups[lvl] || [];
        const n = group.length;
        maxWidth = Math.max(maxWidth, n * NODE_W + (n - 1) * H_GAP);
      }

      const svgWidth = Math.max(maxWidth + 80, 600);
      const positions = {};

      for (let lvl = 0; lvl <= maxLevel; lvl++) {
        const group = levelGroups[lvl] || [];
        const n = group.length;
        const rowWidth = n * NODE_W + (n - 1) * H_GAP;
        const startX = (svgWidth - rowWidth) / 2;
        const y = 60 + lvl * (NODE_H + V_GAP);
        for (let i = 0; i < group.length; i++) {
          positions[group[i]] = { x: startX + i * (NODE_W + H_GAP) + NODE_W / 2, y };
        }
      }

      return positions;
    }

    async function loadFlowchartFromJSON(id) {
      try {
        const resp = await fetch('../techniques.json');
        const data = await resp.json();
        const fc = data.flowcharts.find(f => f.id === id);
        if (!fc) { showStatus('Flowchart not found: ' + id); return; }

        // Store metadata for export
        chartMeta = { id: fc.id, name: fc.name, slide: fc.slide, file: fc.file, rootNode: fc.rootNode };

        // Update title
        const titleEl = document.getElementById('chart-title');
        titleEl.textContent = fc.name;
        titleEl.style.display = 'block';
        document.title = fc.name + ' - Flowchart Editor';

        // Layout tree (same BFS algorithm as gen_flowcharts.py)
        const positions = layoutTree(fc);

        nodes = fc.nodes.map(n => ({
          id: n.id,
          label: n.label,
          type: (n.type === 'reaction') ? 'action' : n.type,
          x: positions[n.id] ? positions[n.id].x : 200,
          y: positions[n.id] ? positions[n.id].y : 200
        }));

        edges = fc.edges.map(e => ({ from: e.from, to: e.to }));
        nextId = nodes.length + 1;
        render();
        showStatus('Loaded: ' + fc.name);
      } catch(e) {
        showStatus('Error loading flowchart');
        console.error(e);
      }
    }

    // Initial render
    render();

    // Load chart from URL param if present
    if (chartId) loadFlowchartFromJSON(chartId);
  })();
  </script>
</body>
</html>
